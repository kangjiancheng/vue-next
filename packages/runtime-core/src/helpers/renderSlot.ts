import { Data } from '../component'
import { Slots, RawSlots } from '../componentSlots'
import {
  ContextualRenderFn,
  currentRenderingInstance
} from '../componentRenderContext'
import { Comment, isVNode } from '../vnode'
import {
  VNodeArrayChildren,
  openBlock,
  createBlock,
  Fragment,
  VNode
} from '../vnode'
import { PatchFlags, SlotFlags } from '@vue/shared'
import { warn } from '../warning'
import { createVNode } from '@vue/runtime-core'

/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */
// 组件节点：
// '<hello-world>
//    <template v-slot:default="slotProps">{{ slotProps.text }}</template>
//  </hello-world>'
// 组件节点 渲染源码code:
// const _component_hello_world = _resolveComponent("hello-world")
//
//     return (_openBlock(), _createBlock(_component_hello_world, null, {
//       default: _withCtx((slotProps) => [
//         _createTextVNode(_toDisplayString(slotProps.text), 1 /* TEXT */)
//       ]),
//       _: 1 /* STABLE */
//     }))
//
// 组件模版：
// 如：'<div class="hello-world">
//       <slot :text="'this is default'"></slot>
//       <slot name="header"></slot>
//     </div>'
// 组件模版 渲染源码code：
//  _createBlock("div", _hoisted_1, [
//    _renderSlot($slots, "default", { text: 'this is default' }),
//    _renderSlot($slots, "header")
//  ])
// 其中 $slots为组件节点的slots子元素列表
export function renderSlot(
  slots: Slots, // 组件的slot列表
  name: string, // 渲染某个slot
  props: Data = {}, // slotProps
  // this is not a user-facing function, so the fallback is always generated by
  // the compiler and guaranteed to be a function returning an array
  fallback?: () => VNodeArrayChildren,
  noSlotted?: boolean
): VNode {
  if (currentRenderingInstance!.isCE) {
    return createVNode(
      'slot',
      name === 'default' ? null : { name },
      fallback && fallback()
    )
  }

  let slot = slots[name] // 得到slots节点渲染方法

  if (__DEV__ && slot && slot.length > 1) {
    warn(
      `SSR-optimized slot function detected in a non-SSR-optimized render ` +
        `function. You need to mark this component with $dynamic-slots in the ` +
        `parent template.`
    )
    slot = () => []
  }

  // a compiled slot disables block tracking by default to avoid manual
  // invocation interfering with template-based block tracking, but in
  // `renderSlot` we can be sure that it's template-based so we can force
  // enable it.
  if (slot && (slot as ContextualRenderFn)._c) {
    ;(slot as ContextualRenderFn)._d = false
  }
  openBlock()
  // 执行slot节点渲染函数，并返回节点vnode，并校验节点的有效
  const validSlotContent = slot && ensureValidVNode(slot(props))

  // 通过fragement片段 封装slot vnode节点
  const rendered = createBlock(
    Fragment,
    { key: props.key || `_${name}` },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && (slots as RawSlots)._ === SlotFlags.STABLE
      ? PatchFlags.STABLE_FRAGMENT
      : PatchFlags.BAIL
  )
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + '-s']
  }
  if (slot && (slot as ContextualRenderFn)._c) {
    ;(slot as ContextualRenderFn)._d = true
  }
  // 返回slot节点的vnode
  return rendered
}

function ensureValidVNode(vnodes: VNodeArrayChildren) {
  return vnodes.some(child => {
    if (!isVNode(child)) return true

    if (child.type === Comment) return false

    if (
      child.type === Fragment &&
      !ensureValidVNode(child.children as VNodeArrayChildren)
    )
      return false

    return true
  })
    ? vnodes
    : null // 如果节点都是注释节点，则为无效slot节点
}
